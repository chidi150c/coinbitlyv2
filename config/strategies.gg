package strategies

import (
	"fmt"
	"log"
	"math"
	"strings"
	"coinbitly.com/config"
	"coinbitly.com/hitbtcapi"
	"coinbitly.com/model"
	"github.com/apourchet/investment/lib/ema"
	"github.com/pkg/errors"
)

// TradingSystem struct: The TradingSystem struct represents the main trading
// system and holds various parameters and fields related to the strategy,
// trading state, and performance.
type TradingSystem struct {
	// Add any necessary fields and indicators here.
	Strategy string
	HistoricalData []model.Candlestick
	ClosingPrices []float64
	Timestamps[]int64
	Signals []string
	ShortPeriod int
	LongPeriod int
	RsiPeriod int
	MacdSignalPeriod int
	BollingerPeriod int
	BollingerNumStdDev float64
	TransactionCost float64
	Slippage float64
	// Fields to track trade state and performance.
	InitialCapital float64
	PositionSize float64
	RiskStopLossPercentage float64
	RiskPositionPercentage float64
	TotalProfitLoss float64
	EntryPrice    float64
	InTrade       bool
	QuoteBalance   float64
	BaseBalance    float64
	StopLossPrice float64
	RiskAmount float64
	DataPoint int
	CurrentPrice float64
	EntryQuantity float64
	StopLossRecover float64
}

// NewTradingSystem(): This function initializes the TradingSystem and fetches 
// historical data from the exchange using the GetCandlesFromExch() function. 
// It sets various strategy parameters like short and long EMA periods, RSI period, 
// MACD signal period, Bollinger Bands period, and more.
func NewTradingSystem() (*TradingSystem, error) {
	// Initialize the trading system.
	ts := &TradingSystem{
		ShortPeriod:        12, // Define moving average short period for the strategy.
		LongPeriod:         26, // Define moving average long period for the strategy.
	}
	ts.RsiPeriod = 14 // Define RSI period parameter.
	ts.MacdSignalPeriod = 9 // Define MACD period parameter.
	ts.BollingerPeriod = 20 // Define Bollinger Bands parameter.
	ts.BollingerNumStdDev = 2.0 // Define Bollinger Bands parameter.
	ts.TransactionCost = 0.001 // Define 0.1% transaction cost
	ts.Slippage = 0.01 // Define 1% slippage
	ts.RiskStopLossPercentage = 0.005 // Define risk management parameter 25% stop-loss
	ts.RiskPositionPercentage = 0.05 // Define risk management parameter 5% balance
	ts.InitialCapital = 6.0 //Initial Capital for simulation on backtesting
	ts.QuoteBalance = ts.InitialCapital //continer to hold the balance
	ts.StopLossRecover = math.MaxFloat64 //
	
	// Fetch historical data from the exchange
	err := ts.UpdateHistoricalData()
	if err != nil {
		return &TradingSystem{}, err
	}
	// Perform any other necessary initialization steps here
	ts.Signals = make([]string, len(ts.ClosingPrices)) // Holder of generated trading signals
	ts.Timestamps = make([]int64, len(ts.ClosingPrices)) // Holder of generated trading signals
	ts.Strategy = "MACD"

	return ts, nil
}

// Backtest(): This function simulates the backtesting process using historical
// price data. It iterates through the closing prices, checks for entry and exit
// conditions, and executes trades accordingly. It also tracks trading performance
// and updates the current balance after each trade.
func (ts *TradingSystem) Backtest() {
	// Initialize variables for tracking trading performance.
	tradeCount := 0
	ts.TotalProfitLoss = 0.0

	// Simulate the backtesting process using historical price data.
	for ts.DataPoint, ts.CurrentPrice = range ts.ClosingPrices {
		// Execute the trade if entry conditions are met.
		if (!ts.InTrade) && (ts.EntryRule() && (ts.CurrentPrice <= ts.StopLossRecover)) {
			tradeCount++

			// Record entry price for calculating profit/loss and stoploss later.
			ts.EntryPrice = ts.CurrentPrice

			// Execute the buy order using the ExecuteStrategy function.
			err := ts.ExecuteStrategy("Buy")
			if err != nil {
				fmt.Println("Error executing buy order:", err)
				ts.Signals[ts.DataPoint] = "Hold" // No Signal - Hold Position
				continue
			}

			// Mark that we are in a trade.
			ts.InTrade = true
			ts.StopLossRecover = math.MaxFloat64
			fmt.Printf("Trade executed at %v - BUY Quant: %.8f, QBal: %.8f, BBal: %.8f, totalP&L %.2f entry: %.8f\n", ts.CurrentPrice, ts.EntryQuantity, ts.QuoteBalance,ts.BaseBalance, ts.TotalProfitLoss, ts.EntryPrice)

		// Close the trade if exit conditions are met.
		} else if ts.InTrade && ts.ExitRule() {
			tradeCount++

			// Execute the sell order using the ExecuteStrategy function.
			err := ts.ExecuteStrategy("Sell")
			if err != nil {
				if fmt.Sprintf("%v", err) == "Stoploss Triggered"{
					ts.InTrade = false
					fmt.Println(err, ": StoplossRecover", ts.StopLossRecover)
					continue
				}
				fmt.Println("Error:", err, " at:", ts.CurrentPrice, ", Stoploss below::", ts.StopLossPrice)
				ts.Signals[ts.DataPoint] = "Hold" // No Signal - Hold Position
				continue
			}

			fmt.Printf("Trade closed at %v - SELL Quant: %.8f, QBal: %.8f, BBal: %.8f, totalP&L %.2f\n", ts.CurrentPrice, ts.EntryQuantity, ts.QuoteBalance, ts.BaseBalance, ts.TotalProfitLoss)

			// Mark that we are no longer in a trade.
			ts.InTrade = false

			// Implement risk management and update capital after each trade
			// For simplicity, we'll skip this step in this basic example

		} else {
			ts.Signals[ts.DataPoint] = "Hold" // No Signal - Hold Position
		}

		// Perform other necessary tasks, such as recording trading performance.
		// For real-world backtesting, you may need to track portfolio value, profit/loss, etc.
	}

	// Print the overall trading performance after backtesting.
	fmt.Printf("\nBacktesting Summary:\n")
	fmt.Printf("Total Trades: %d\n", tradeCount)
	fmt.Printf("Total Profit/Loss: %.2f\n", ts.TotalProfitLoss)
	fmt.Printf("Final Capital: %.2f\n", ts.QuoteBalance)
	fmt.Printf("Final Asset: %.2f\n", ts.BaseBalance)

	err := CreateLineChartWithSignals(ts.Timestamps, ts.ClosingPrices, ts.Signals)
	if err != nil {
		fmt.Println("Error creating Line Chart with signals:", err)
		return
	}
}


// ExecuteStrategy executes the trade based on the provided trade action and current price.
// The tradeAction parameter should be either "Buy" or "Sell".
func (ts *TradingSystem) ExecuteStrategy(tradeAction string) error {
	// Calculate position size based on the fixed percentage of risk per trade.
	isStopLossExecuted := ts.RiskManagement() // make sure entry price is set before calling risk management
	if isStopLossExecuted{
		return errors.New("Stoploss Triggered")
	}
	switch tradeAction {
	case "Buy":
		if ts.InTrade {
			return fmt.Errorf("cannot execute a buy order while already in a trade")
		}

		// Update the current balance after the trade (considering transaction fees and slippage).
		transactionCost := ts.TransactionCost * ts.CurrentPrice * ts.PositionSize
		slippageCost := ts.Slippage * ts.CurrentPrice * ts.PositionSize
		
		// Mark that we are in a trade.
		ts.InTrade = true

		// Record Signal for plotting graph later
		ts.Signals[ts.DataPoint] = "Buy"

		// Update the quote and base balances after the trade.
		ts.QuoteBalance -= (ts.PositionSize * ts.CurrentPrice) + transactionCost + slippageCost
		ts.BaseBalance += ts.PositionSize

		// Record entry price for calculating profit/loss later.
		ts.EntryQuantity = ts.PositionSize

		return nil

	case "Sell":
		if !ts.InTrade {
			return fmt.Errorf("cannot execute a sell order without an existing trade")
		}

		// Calculate profit/loss for the trade.
		exitPrice := ts.CurrentPrice
		tradeProfitLoss := CalculateProfitLoss(ts.EntryPrice, exitPrice, ts.EntryQuantity)
		transactionCost := ts.TransactionCost * exitPrice * ts.EntryQuantity
		slippageCost := ts.Slippage * exitPrice * ts.EntryQuantity
		
		if tradeProfitLoss < (transactionCost + slippageCost)*(1+0.5){
			return fmt.Errorf("cannot execute a sell order without profit")
		}else{
			tradeProfitLoss -= transactionCost + slippageCost
		}

		// Mark that we are no longer in a trade.
		ts.InTrade = false

		
		// Store profit/loss for the trade.
		ts.TotalProfitLoss += tradeProfitLoss


		// Update the quote and base balances after the trade.
		ts.QuoteBalance += (ts.EntryQuantity * exitPrice) - transactionCost - slippageCost
		ts.BaseBalance -= ts.EntryQuantity

		// Record Signal for plotting graph later
		ts.Signals[ts.DataPoint] = "Sell"

		return nil

	default:
		return fmt.Errorf("invalid trade action: %s", tradeAction)
	}
}

// RiskManagement applies risk management rules to limit potential losses.
// It calculates the stop-loss price based on the fixed percentage of risk per trade and the position size.
// If the current price breaches the stop-loss level, it triggers a sell signal and exits the trade.
func (ts *TradingSystem) RiskManagement() bool{
	// Calculate stop-loss price based on the fixed percentage of risk per trade.
	ts.StopLossPrice = ts.EntryPrice * (1.0 - ts.RiskStopLossPercentage)

	// Calculate position size based on the fixed percentage of risk per trade.
	ts.RiskAmount = ts.QuoteBalance * ts.RiskPositionPercentage
	ts.PositionSize = ts.RiskAmount / ts.StopLossPrice

	// Check if the current price breaches the stop-loss level and triggers a sell signal.
	if ts.InTrade && ts.CurrentPrice <= ts.StopLossPrice { 
		// Calculate profit/loss for the trade.
		exitPrice := ts.CurrentPrice
		tradeProfitLoss := CalculateProfitLoss(ts.EntryPrice, exitPrice, ts.EntryQuantity)
		transactionCost := ts.TransactionCost * exitPrice * ts.EntryQuantity
		slippageCost := ts.Slippage * exitPrice * ts.EntryQuantity
		tradeProfitLoss -= transactionCost + slippageCost
		ts.TotalProfitLoss += tradeProfitLoss

		// Update the quote and base balances after the trade.
		ts.QuoteBalance += (ts.EntryQuantity * exitPrice) - transactionCost - slippageCost
		ts.BaseBalance -= ts.EntryQuantity

		// Record Signal for plotting graph later.
		ts.Signals[ts.DataPoint] = "Sell"
		
		fmt.Printf("Stop-Loss Triggered at %v - SELL Quant: %.8f, Price: %.8f, QBal: %.8f, BBal: %.8f, totalP&L %.2f stoploss: %.8f\n",
			ts.CurrentPrice, ts.EntryQuantity, ts.RiskAmount, ts.QuoteBalance, ts.BaseBalance, ts.TotalProfitLoss, ts.StopLossPrice)

		// Mark that we are no longer in a trade.
		ts.InTrade = false
		ts.StopLossRecover = ts.CurrentPrice * (1.0 - ts.RiskStopLossPercentage)
		return true
	}
	return false
}


// TechnicalAnalysis(): This function performs technical analysis using the 
// calculated moving averages (short and long EMA), RSI, MACD line, and Bollinger 
// Bands. It determines the buy and sell signals based on various strategy rules.
func (ts *TradingSystem) TechnicalAnalysis() (buySignal, sellSignal bool) {
	// Calculate moving averages (MA) using historical data.
	longEMA, shortEMA, timeStamps, err := ts.CandleExponentialMovingAverage()
	if err != nil {
		log.Fatalf("Error: in TechnicalAnalysis Unable to get EMA: %v", err)
	}
	// Calculate Relative Strength Index (RSI) using historical data.
	rsi := CalculateRSI(ts.ClosingPrices, ts.RsiPeriod)

	// Calculate MACD and Signal Line using historical data.
	macdLine, signalLine, macdHistogram := ts.CalculateMACD()

	// Calculate Bollinger Bands using historical data.
	_, upperBand, lowerBand := CalculateBollingerBands(ts.ClosingPrices, ts.BollingerPeriod, ts.BollingerNumStdDev)

	// Determine the buy and sell signals based on the moving averages, RSI, MACD line, and Bollinger Bands.
	if len(shortEMA) > 1 && len(longEMA) > 1 && len(rsi) > 0 && len(macdLine) > 1 && len(signalLine) > 1 && len(upperBand) > 0 && len(lowerBand) > 0 {
		// Get the latest moving average values, RSI, MACD line, and Bollinger Bands.
		currentRSI := 0.0
		if ts.DataPoint > 0 {
			previousshortEMA := shortEMA[ts.DataPoint-1]
			previouslongEMA := longEMA[ts.DataPoint-1]
			currentshortEMA := shortEMA[ts.DataPoint]
			currentlongEMA := longEMA[ts.DataPoint]		
			if ts.DataPoint <= len(rsi){
				 currentRSI= rsi[ts.DataPoint-1]
			}
			previousMACDLine := macdLine[ts.DataPoint-1]
			currentMACDLine := macdLine[ts.DataPoint]
			previousSignalLine := signalLine[ts.DataPoint]
			currentSignalLine := signalLine[ts.DataPoint]
			// currentUpperBand := upperBand[ts.DataPoint]
			// currentLowerBand := lowerBand[ts.DataPoint]
			currentMacdHistogram := macdHistogram[ts.DataPoint]
			
			// Buy Signal:
			// Short-term MA crosses above long-term MA,
			// RSI is below 30 (oversold),
			// Price is below the lower Bollinger Band, and
			// MACD crosses above the Signal Line.
			// buySignal = previousshortEMA <= previouslongEMA && currentshortEMA > currentlongEMA && currentRSI < 30 && ts.ClosingPrices[len(ts.ClosingPrices)-1] < currentLowerBand && previousMACDLine <= previousSignalLine && currentMACDLine > currentSignalLine
					
			// Sell Signal:
			// Short-term MA crosses below long-term MA,
			// RSI is above 70 (overbought),
			// Price is above the upper Bollinger Band, and
			// MACD crosses below the Signal Line.
			// var (
			// 	buyEMASignal bool
			// 	sellEMASignal bool
			// 	buyMACDSignal bool
			// 	sellMACDSignal bool
			// 	buyRSISignal bool
			// 	sellRSISignal bool
			// 	buyBollingerSignal bool
			// 	sellBollingerSignal bool
			// )
			count := 0 
			buySignal, sellSignal = true, true
			if strings.Contains(ts.Strategy, "EMA"){
				count++
				buySignal = buySignal && previousshortEMA <= previouslongEMA && 
								currentshortEMA > currentlongEMA 
				sellSignal = sellSignal && previousshortEMA >= previouslongEMA && 
								currentshortEMA < currentlongEMA
			}
			if strings.Contains(ts.Strategy, "RSI") {
				count++
				buySignal = buySignal && currentRSI < 30 
				sellSignal = sellSignal && currentRSI > 70 
			}
			if strings.Contains(ts.Strategy, "MACD"){
				count++
				buySignal = buySignal && previousMACDLine <= previousSignalLine && 
								currentMACDLine > currentSignalLine && 
								currentMacdHistogram > 0
				sellSignal = sellSignal && previousMACDLine >= previousSignalLine && 
								currentMACDLine < currentSignalLine && 
								currentMacdHistogram < 0
			}
			// if strings.Contains(ts.Strategy, "Bollinger") {
			// count++
			// 	buySignal = buySignal && ts.ClosingPrices[len(ts.ClosingPrices)-1] < currentLowerBand 
			// 	sellSignal = sellSignal && ts.ClosingPrices[len(ts.ClosingPrices)-1] > currentUpperBand
			// }
			if count == 0 {
				buySignal, sellSignal = false, false
			}
			_ = timeStamps
			// PlotEMA(timeStamps, longEMA, shortEMA)
		}
		// fmt.Printf("EMA: %v, RSI: %v, MACD: %v, Bollinger: %v buySignal: %v, sellSignal: %v", ts.Strategy.UseEMA, ts.Strategy.UseRSI, ts.Strategy.UseMACD, ts.Strategy.UseBollinger, buySignal, sellSignal)
	}

	return buySignal, sellSignal
}

// FundamentalAnalysis performs fundamental analysis and generates trading signals.
func (ts *TradingSystem) FundamentalAnalysis() (buySignal, sellSignal bool) {
	// Implement your fundamental analysis logic here.
	// Analyze project fundamentals, team credentials, market news, etc.
	// Determine the buy and sell signals based on the analysis.
	// Return true for buySignal and sellSignal if conditions are met.
	return false, false
}

// EntryRule defines the entry conditions for a trade.
func (ts *TradingSystem) EntryRule() bool {
	// Combine the results of technical and fundamental analysis to decide entry conditions.
	technicalBuy, _ := ts.TechnicalAnalysis()
	// fundamentalBuy, fundamentalSell := ts.FundamentalAnalysis()
	return technicalBuy 
}

// ExitRule defines the exit conditions for a trade.
func (ts *TradingSystem) ExitRule() bool {
	// Combine the results of technical and fundamental analysis to decide exit conditions.
	_, technicalSell := ts.TechnicalAnalysis()
	// fundamentalBuy, fundamentalSell := ts.FundamentalAnalysis()
	return technicalSell
}

// UpdateClosingPrices fetches historical data from the exchange and updates the ClosingPrices field in TradingSystem.
func (ts *TradingSystem) UpdateHistoricalData() error {
	var err error
	exchConfig := config.NewExchangesConfig()
    hitbtcExch, err := hitbtcapi.NewExchServices(exchConfig)
    if err != nil{
        log.Fatal(err)
    }
    ts.HistoricalData, err = hitbtcExch.FetchHistoricalCandlesticks(hitbtcExch.Symbol, hitbtcExch.CandleInterval, hitbtcExch.CandleStartTime, hitbtcExch.CandleEndTime)
	
	if err != nil {
		return err
	}
	// Extract the closing prices from the candles data
	for _, candle := range ts.HistoricalData {
		ts.ClosingPrices = append(ts.ClosingPrices, candle.Close)
	}
	return nil
}

// CalculateMACD calculates the Moving Average Convergence Divergence (MACD) and MACD Histogram for the given data and periods.
func (ts *TradingSystem) CalculateMACD() (macdLine, signalLine, macdHistogram []float64) {
	longEMA, shortEMA, _, err := ts.CandleExponentialMovingAverage()
	if err != nil {
		log.Fatalf("Error: in CalclateMACD while tring to get EMA")
	}
	// Calculate MACD line
	macdLine = make([]float64, len(ts.ClosingPrices))
	for i := range ts.ClosingPrices {
		macdLine[i] = shortEMA[i] - longEMA[i]
	}

	// Calculate signal line using the MACD line
	signalLine = CalculateExponentialMovingAverage(macdLine, ts.MacdSignalPeriod)

	// Calculate MACD Histogram
	macdHistogram = make([]float64, len(ts.ClosingPrices))
	for i := range ts.ClosingPrices {
		macdHistogram[i] = macdLine[i] - signalLine[i]
	}

	return macdLine, signalLine, macdHistogram
}

//CandleExponentialMovingAverage calculates EMA from condles
func (ts *TradingSystem) CandleExponentialMovingAverage() (longEMA, shortEMA []float64, timestamps []int64, err error) {
	ema55 := ema.NewEma(alphaFromN(ts.LongPeriod))
	ema15 := ema.NewEma(alphaFromN(ts.ShortPeriod))

	longEMA = make([]float64, len(ts.HistoricalData))
	shortEMA = make([]float64, len(ts.HistoricalData))
	timestamps = make([]int64, len(ts.HistoricalData))
	for k, candle := range ts.HistoricalData {
		ema55.Step(candle.Close)
		ema15.Step(candle.Close)
		longEMA[k] = ema55.Compute()
		shortEMA[k] = ema15.Compute()
		timestamps[k] = candle.Timestamp
	}
	return longEMA, shortEMA, timestamps, nil
}

// CalculateProfitLoss calculates the profit or loss from a trade.
func CalculateProfitLoss(entryPrice, exitPrice, positionSize float64) float64 {
	return (exitPrice - entryPrice) * positionSize
}

func CalculateSimpleMovingAverage(data []float64, period int) (sma []float64) {
	if period <= 0 || len(data) < period {
		return nil
	}

	sma = make([]float64, len(data)-period+1)
	for i := 0; i <= len(data)-period; i++ {
		sum := 0.0
		for j := i; j < i+period; j++ {
			sum += data[j]
		}
		sma[i] = sum / float64(period)
	}

	return sma
}


func CalculateStandardDeviation(data []float64, period int) []float64 {
	if period <= 0 || len(data) < period {
		return nil
	}

	stdDev := make([]float64, len(data)-period+1)
	for i := 0; i <= len(data)-period; i++ {
		avg := CalculateSimpleMovingAverage(data[i:i+period], period)[0]
		variance := 0.0
		for j := i; j < i+period; j++ {
			variance += math.Pow(data[j]-avg, 2)
		}
		stdDev[i] = math.Sqrt(variance / float64(period))
	}

	return stdDev
}
func alphaFromN(N int) float64 {
	var n = float64(N)
	return 2. / (n + 1.)
}

// CalculateExponentialMovingAverage calculates the Exponential Moving Average (EMA) for the given data and period.
func CalculateExponentialMovingAverage(data []float64, period int) (ema []float64) {
	ema = make([]float64, len(data))
	smoothingFactor := 2.0 / (float64(period) + 1.0)

	// Calculate the initial SMA as the sum of the first 'period' data points divided by 'period'.
	sma := 0.0
	for i := 0; i < period; i++ {
		sma += data[i]
	}
	ema[period-1] = sma / float64(period)

	// Calculate the EMA for the remaining data points.
	for i := period; i < len(data); i++ {
		ema[i] = (data[i] - ema[i-1]) * smoothingFactor + ema[i-1]
	}

	return ema
}

// CalculateRSI calculates the Relative Strength Index (RSI) for the given data and period.
func CalculateRSI(data []float64, period int) []float64 {
	rsiValues := make([]float64, 0, len(data))

	if len(data) < period {
		return rsiValues
	}

	// Calculate the first average gain and loss for the initial period.
	var avgGain, avgLoss float64
	for i := 1; i < period; i++ {
		change := data[i] - data[i-1]
		if change > 0 {
			avgGain += change
		} else {
			avgLoss += -change
		}
	}
	avgGain /= float64(period)
	avgLoss /= float64(period)

	// Calculate RSI values for the remaining data.
	for i := period; i < len(data); i++ {
		change := data[i] - data[i-1]
		if change > 0 {
			avgGain = (avgGain*(float64(period-1)) + change) / float64(period)
			avgLoss = (avgLoss * float64(period-1)) / float64(period)
		} else {
			avgGain = (avgGain * float64(period-1)) / float64(period)
			avgLoss = (avgLoss*(float64(period-1)) + (-change)) / float64(period)
		}

		rs := avgGain / avgLoss
		rsi := 100.0 - (100.0 / (1.0 + rs))
		rsiValues = append(rsiValues, rsi)
	}

	return rsiValues
}

// CalculateBollingerBands calculates the middle (SMA) and upper/lower Bollinger Bands for the given data and period.
func CalculateBollingerBands(data []float64, period int, numStdDev float64) ([]float64, []float64, []float64) {
	sma := CalculateSimpleMovingAverage(data, period)
	stdDev := CalculateStandardDeviation(data, period)

	upperBand := make([]float64, len(sma))
	lowerBand := make([]float64, len(sma))

	for i := range sma {
		upperBand[i] = sma[i] + numStdDev*stdDev[i]
		lowerBand[i] = sma[i] - numStdDev*stdDev[i]
	}

	return sma, upperBand, lowerBand
}




